{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport * as React from 'react';\nimport { createRef } from 'react';\nimport PropTypes from 'prop-types';\nimport WebMercatorViewport from 'viewport-mercator-project';\nimport mapboxgl from '../utils/mapboxgl';\nimport BaseControl from './base-control';\nimport Marker from './marker';\nimport MapState from '../utils/map-state';\nimport TransitionManager from '../utils/transition-manager';\nimport { isGeolocationSupported } from '../utils/geolocate-utils';\nvar LINEAR_TRANSITION_PROPS = Object.assign({}, TransitionManager.defaultProps, {\n  transitionDuration: 500\n});\n\nvar noop = function noop() {};\n\nvar propTypes = Object.assign({}, BaseControl.propTypes, {\n  className: PropTypes.string,\n  style: PropTypes.object,\n  label: PropTypes.string,\n  auto: PropTypes.bool,\n  positionOptions: PropTypes.object,\n  fitBoundsOptions: PropTypes.object,\n  trackUserLocation: PropTypes.bool,\n  showUserLocation: PropTypes.bool,\n  onViewStateChange: PropTypes.func,\n  onViewportChange: PropTypes.func,\n  onGeolocate: PropTypes.func\n});\nvar defaultProps = Object.assign({}, BaseControl.defaultProps, {\n  className: '',\n  style: {},\n  label: 'Geolocate',\n  auto: false,\n  positionOptions: null,\n  fitBoundsOptions: null,\n  trackUserLocation: false,\n  showUserLocation: true,\n  onGeolocate: function onGeolocate() {}\n});\n\nvar GeolocateControl = function (_BaseControl) {\n  _inherits(GeolocateControl, _BaseControl);\n\n  var _super = _createSuper(GeolocateControl);\n\n  function GeolocateControl() {\n    var _this;\n\n    _classCallCheck(this, GeolocateControl);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      supportsGeolocation: false,\n      markerPosition: null\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_mapboxGeolocateControl\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"_geolocateButtonRef\", createRef());\n\n    _defineProperty(_assertThisInitialized(_this), \"_setupMapboxGeolocateControl\", function (supportsGeolocation) {\n      if (!supportsGeolocation) {\n        console.warn('Geolocation support is not available, the GeolocateControl will not be visible.');\n        return;\n      }\n\n      var controlOptions = {\n        showUserLocation: false\n      };\n      ['positionOptions', 'fitBoundsOptions', 'trackUserLocation'].forEach(function (prop) {\n        if (prop in _this.props && _this.props[prop] !== null) {\n          controlOptions[prop] = _this.props[prop];\n        }\n      });\n      var control = new mapboxgl.GeolocateControl(controlOptions);\n      _this._mapboxGeolocateControl = control;\n      control._watchState = 'OFF';\n      control._geolocateButton = _this._geolocateButtonRef.current;\n\n      if (control.options.trackUserLocation && control._geolocateButton) {\n        control._geolocateButton.setAttribute('aria-pressed', 'false');\n      }\n\n      control._updateMarker = _this._updateMarker;\n      control._updateCamera = _this._updateCamera;\n      control._setup = true;\n      var eventManager = _this._context.eventManager;\n\n      if (control.options.trackUserLocation && eventManager) {\n        eventManager.on('panstart', function () {\n          if (control._watchState === 'ACTIVE_LOCK') {\n            control._watchState = 'BACKGROUND';\n\n            control._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background');\n\n            control._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active');\n          }\n        });\n      }\n\n      control.on('geolocate', _this.props.onGeolocate);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_triggerGeolocate\", function () {\n      var control = _this._mapboxGeolocateControl;\n      control._map = _this._context.map;\n\n      if (_this.props.showUserLocation) {\n        control.on('geolocate', _this._updateMarker);\n        control.on('trackuserlocationend', _this._updateMarker);\n      }\n\n      return _this._mapboxGeolocateControl.trigger();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_updateMarker\", function (position) {\n      if (position) {\n        _this.setState({\n          markerPosition: position.coords\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_getBounds\", function (position) {\n      var center = new mapboxgl.LngLat(position.coords.longitude, position.coords.latitude);\n      var radius = position.coords.accuracy;\n      var bounds = center.toBounds(radius);\n      return [[bounds._ne.lng, bounds._ne.lat], [bounds._sw.lng, bounds._sw.lat]];\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_updateCamera\", function (position) {\n      var viewport = _this._context.viewport;\n\n      var bounds = _this._getBounds(position);\n\n      var _WebMercatorViewport$ = new WebMercatorViewport(viewport).fitBounds(bounds),\n          longitude = _WebMercatorViewport$.longitude,\n          latitude = _WebMercatorViewport$.latitude,\n          zoom = _WebMercatorViewport$.zoom;\n\n      var newViewState = Object.assign({}, viewport, {\n        longitude: longitude,\n        latitude: latitude,\n        zoom: zoom\n      });\n      var mapState = new MapState(newViewState);\n      var viewState = Object.assign({}, mapState.getViewportProps(), LINEAR_TRANSITION_PROPS);\n      var onViewportChange = _this.props.onViewportChange || _this._context.onViewportChange || noop;\n      var onViewStateChange = _this.props.onViewStateChange || _this._context.onViewStateChange || noop;\n      onViewStateChange({\n        viewState: viewState\n      });\n      onViewportChange(viewState);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_renderButton\", function (type, label, callback) {\n      return React.createElement(\"button\", {\n        key: type,\n        className: \"mapboxgl-ctrl-icon mapboxgl-ctrl-\".concat(type),\n        ref: _this._geolocateButtonRef,\n        type: \"button\",\n        title: label,\n        onClick: callback\n      }, React.createElement(\"span\", {\n        className: \"mapboxgl-ctrl-icon\",\n        \"aria-hidden\": \"true\"\n      }));\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_renderMarker\", function () {\n      var markerPosition = _this.state.markerPosition;\n      var showUserLocation = _this.props.showUserLocation;\n\n      if (!markerPosition || !showUserLocation) {\n        return null;\n      }\n\n      return React.createElement(Marker, {\n        key: \"location-maker\",\n        longitude: markerPosition.longitude,\n        latitude: markerPosition.latitude,\n        captureDrag: false,\n        captureDoubleClick: false\n      }, React.createElement(\"div\", {\n        className: \"mapboxgl-user-location-dot\",\n        style: {\n          transform: 'translate(-50%, -50%)'\n        }\n      }));\n    });\n\n    return _this;\n  }\n\n  _createClass(GeolocateControl, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      isGeolocationSupported().then(function (result) {\n        _this2.setState({\n          supportsGeolocation: result\n        });\n\n        _this2._setupMapboxGeolocateControl(result);\n\n        if (result && _this2.props.auto) {\n          _this2._triggerGeolocate();\n        }\n      });\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (this.state.supportsGeolocation && !prevProps.auto && this.props.auto) {\n        this._triggerGeolocate();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this._mapboxGeolocateControl) {\n        var geolocationWatchID = this._mapboxGeolocateControl._geolocationWatchID;\n\n        if (geolocationWatchID !== undefined) {\n          window.navigator.geolocation.clearWatch(geolocationWatchID);\n          this._mapboxGeolocateControl._geolocationWatchID = undefined;\n        }\n      }\n    }\n  }, {\n    key: \"_render\",\n    value: function _render() {\n      if (!this.state.supportsGeolocation) {\n        return null;\n      }\n\n      var _this$props = this.props,\n          className = _this$props.className,\n          style = _this$props.style,\n          label = _this$props.label;\n      return React.createElement(\"div\", null, this._renderMarker(), React.createElement(\"div\", {\n        key: \"geolocate-control\",\n        className: \"mapboxgl-ctrl mapboxgl-ctrl-group \".concat(className),\n        ref: this._containerRef,\n        style: style\n      }, this._renderButton('geolocate', label, this._triggerGeolocate)));\n    }\n  }]);\n\n  return GeolocateControl;\n}(BaseControl);\n\n_defineProperty(GeolocateControl, \"propTypes\", propTypes);\n\n_defineProperty(GeolocateControl, \"defaultProps\", defaultProps);\n\nexport { GeolocateControl as default };","map":{"version":3,"sources":["../../../src/components/geolocate-control.js"],"names":["LINEAR_TRANSITION_PROPS","TransitionManager","transitionDuration","noop","propTypes","BaseControl","className","PropTypes","style","label","auto","positionOptions","fitBoundsOptions","trackUserLocation","showUserLocation","onViewStateChange","onViewportChange","onGeolocate","func","defaultProps","GeolocateControl","supportsGeolocation","markerPosition","createRef","isGeolocationSupported","result","prevProps","geolocationWatchID","window","console","controlOptions","prop","control","mapboxgl","eventManager","position","coords","center","radius","bounds","viewport","longitude","latitude","zoom","newViewState","mapState","viewState","Object","callback","transform"],"mappings":"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","sourcesContent":["// @flow\n\n/* global window */\nimport * as React from 'react';\nimport {createRef} from 'react';\nimport PropTypes from 'prop-types';\nimport WebMercatorViewport from 'viewport-mercator-project';\n\nimport mapboxgl from '../utils/mapboxgl';\n\nimport BaseControl from './base-control';\nimport Marker from './marker';\nimport MapState from '../utils/map-state';\nimport TransitionManager from '../utils/transition-manager';\nimport {isGeolocationSupported} from '../utils/geolocate-utils';\n\nimport type {BaseControlProps} from './base-control';\n\nconst LINEAR_TRANSITION_PROPS = Object.assign({}, TransitionManager.defaultProps, {\n  transitionDuration: 500\n});\n\nconst noop = () => {};\n\nconst propTypes = Object.assign({}, BaseControl.propTypes, {\n  // Custom className\n  className: PropTypes.string,\n  style: PropTypes.object,\n  // Custom label assigned to the control\n  label: PropTypes.string,\n  // Auto trigger instead of waiting for click\n  auto: PropTypes.bool,\n\n  // mapbox geolocate options\n  // https://docs.mapbox.com/mapbox-gl-js/api/#geolocatecontrol\n  positionOptions: PropTypes.object,\n  fitBoundsOptions: PropTypes.object,\n  trackUserLocation: PropTypes.bool,\n  showUserLocation: PropTypes.bool,\n\n  // Callbacks fired when the user interacted with the map. The object passed to the callbacks\n  // contains viewport properties such as `longitude`, `latitude`, `zoom` etc.\n  onViewStateChange: PropTypes.func,\n  onViewportChange: PropTypes.func,\n\n  onGeolocate: PropTypes.func\n});\n\nconst defaultProps = Object.assign({}, BaseControl.defaultProps, {\n  className: '',\n  style: {},\n  label: 'Geolocate',\n  auto: false,\n\n  // mapbox geolocate options\n  positionOptions: null,\n  fitBoundsOptions: null,\n  trackUserLocation: false,\n  showUserLocation: true,\n\n  onGeolocate: () => {}\n});\n\nexport type GeolocateControlProps = BaseControlProps & {\n  className: string,\n  style: Object,\n  label: string,\n  auto: boolean,\n  positionOptions: any,\n  fitBoundsOptions: any,\n  trackUserLocation: boolean,\n  showUserLocation: boolean,\n  onViewStateChange?: Function,\n  onViewportChange?: Function,\n  onGeolocate?: Function\n};\n\ntype Coordinate = {\n  longitude: number,\n  latitude: number,\n  accuracy: number\n};\ntype Position = {\n  coords: Coordinate\n};\ntype State = {\n  supportsGeolocation: boolean,\n  markerPosition: ?Coordinate\n};\ntype GeolocateControlOptions = {\n  positionOptions?: any,\n  fitBoundsOptions?: any,\n  trackUserLocation?: boolean,\n  showUserLocation?: boolean\n};\n\nexport default class GeolocateControl extends BaseControl<\n  GeolocateControlProps,\n  State,\n  HTMLDivElement\n> {\n  static propTypes = propTypes;\n  static defaultProps = defaultProps;\n\n  state = {\n    supportsGeolocation: false,\n    markerPosition: null\n  };\n\n  _mapboxGeolocateControl: any = null;\n\n  _geolocateButtonRef: {current: null | HTMLButtonElement} = createRef();\n\n  componentDidMount() {\n    isGeolocationSupported().then(result => {\n      this.setState({supportsGeolocation: result});\n      this._setupMapboxGeolocateControl(result);\n      if (result && this.props.auto) {\n        this._triggerGeolocate();\n      }\n    });\n  }\n\n  componentDidUpdate(prevProps: GeolocateControlProps) {\n    // trigger geolocate when prop auto changes to true\n    // change to false has no effect\n    if (this.state.supportsGeolocation && !prevProps.auto && this.props.auto) {\n      this._triggerGeolocate();\n    }\n  }\n\n  componentWillUnmount() {\n    // re-implement MapboxGeolocateControl's _onRemove\n    // clear the geolocation watch if exists\n    if (this._mapboxGeolocateControl) {\n      const geolocationWatchID = this._mapboxGeolocateControl._geolocationWatchID;\n      if (geolocationWatchID !== undefined) {\n        window.navigator.geolocation.clearWatch(geolocationWatchID);\n        this._mapboxGeolocateControl._geolocationWatchID = undefined;\n      }\n    }\n  }\n\n  _setupMapboxGeolocateControl = (supportsGeolocation: boolean) => {\n    if (!supportsGeolocation) {\n      /* eslint-disable no-console, no-undef */\n      console.warn(\n        'Geolocation support is not available, the GeolocateControl will not be visible.'\n      );\n      /* eslint-enable no-console, no-undef */\n      return;\n    }\n\n    // For null option, use Mapbox default value\n    const controlOptions: GeolocateControlOptions = {\n      // disable showUserLocation to avoid Mapbox accessing marker before rendering\n      showUserLocation: false\n    };\n    ['positionOptions', 'fitBoundsOptions', 'trackUserLocation'].forEach(prop => {\n      if (prop in this.props && this.props[prop] !== null) {\n        controlOptions[prop] = this.props[prop];\n      }\n    });\n\n    const control = new mapboxgl.GeolocateControl(controlOptions);\n    this._mapboxGeolocateControl = control;\n\n    // the following re-implement MapboxGeolocateControl's _setupUI\n    // replace mapbox internal prop\n    control._watchState = 'OFF';\n\n    // replace mapbox internal UI elements\n    control._geolocateButton = this._geolocateButtonRef.current;\n    if (control.options.trackUserLocation && control._geolocateButton) {\n      control._geolocateButton.setAttribute('aria-pressed', 'false');\n    }\n\n    // replace mapbox internal methods\n    control._updateMarker = this._updateMarker;\n    control._updateCamera = this._updateCamera;\n\n    control._setup = true;\n\n    // when the camera is changed (and it's not as a result of the Geolocation Control) change\n    // the watch mode to background watch, so that the marker is updated but not the camera.\n    const {eventManager} = this._context;\n    if (control.options.trackUserLocation && eventManager) {\n      eventManager.on('panstart', () => {\n        if (control._watchState === 'ACTIVE_LOCK') {\n          control._watchState = 'BACKGROUND';\n          control._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background');\n          control._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active');\n        }\n      });\n    }\n\n    control.on('geolocate', this.props.onGeolocate);\n  };\n\n  _triggerGeolocate = () => {\n    const control = this._mapboxGeolocateControl;\n    control._map = this._context.map;\n\n    if (this.props.showUserLocation) {\n      control.on('geolocate', this._updateMarker);\n      control.on('trackuserlocationend', this._updateMarker);\n    }\n\n    return this._mapboxGeolocateControl.trigger();\n  };\n\n  _updateMarker = (position: Position) => {\n    if (position) {\n      this.setState({markerPosition: position.coords});\n    }\n  };\n\n  _getBounds = (position: Position) => {\n    const center = new mapboxgl.LngLat(position.coords.longitude, position.coords.latitude);\n    const radius = position.coords.accuracy;\n    const bounds = center.toBounds(radius);\n\n    return [[bounds._ne.lng, bounds._ne.lat], [bounds._sw.lng, bounds._sw.lat]];\n  };\n\n  _updateCamera = (position: Position) => {\n    const {viewport} = this._context;\n\n    const bounds = this._getBounds(position);\n    const {longitude, latitude, zoom} = new WebMercatorViewport(viewport).fitBounds(bounds);\n\n    const newViewState = Object.assign({}, viewport, {\n      longitude,\n      latitude,\n      zoom\n    });\n    const mapState = new MapState(newViewState);\n    const viewState = Object.assign({}, mapState.getViewportProps(), LINEAR_TRANSITION_PROPS);\n\n    const onViewportChange = this.props.onViewportChange || this._context.onViewportChange || noop;\n    const onViewStateChange =\n      this.props.onViewStateChange || this._context.onViewStateChange || noop;\n\n    // Call new style callback\n    onViewStateChange({viewState});\n\n    // Call old style callback\n    onViewportChange(viewState);\n  };\n\n  _renderButton = (type: string, label: string, callback: Function) => {\n    return (\n      <button\n        key={type}\n        className={`mapboxgl-ctrl-icon mapboxgl-ctrl-${type}`}\n        ref={this._geolocateButtonRef}\n        type=\"button\"\n        title={label}\n        onClick={callback}\n      >\n        <span className=\"mapboxgl-ctrl-icon\" aria-hidden=\"true\" />\n      </button>\n    );\n  };\n\n  _renderMarker = () => {\n    const {markerPosition} = this.state;\n    const {showUserLocation} = this.props;\n    if (!markerPosition || !showUserLocation) {\n      return null;\n    }\n\n    return (\n      // $FlowFixMe\n      <Marker\n        key=\"location-maker\"\n        longitude={markerPosition.longitude}\n        latitude={markerPosition.latitude}\n        captureDrag={false}\n        captureDoubleClick={false}\n      >\n        <div className=\"mapboxgl-user-location-dot\" style={{transform: 'translate(-50%, -50%)'}} />\n      </Marker>\n    );\n  };\n\n  _render() {\n    if (!this.state.supportsGeolocation) {\n      return null;\n    }\n\n    const {className, style, label} = this.props;\n    return (\n      <div>\n        {this._renderMarker()}\n        <div\n          key=\"geolocate-control\"\n          className={`mapboxgl-ctrl mapboxgl-ctrl-group ${className}`}\n          ref={this._containerRef}\n          style={style}\n        >\n          {this._renderButton('geolocate', label, this._triggerGeolocate)}\n        </div>\n      </div>\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}