{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport { Manager } from './utils/hammer';\nimport WheelInput from './inputs/wheel-input';\nimport MoveInput from './inputs/move-input';\nimport KeyInput from './inputs/key-input';\nimport ContextmenuInput from './inputs/contextmenu-input';\nimport EventRegistrar from './utils/event-registrar';\nimport { BASIC_EVENT_ALIASES, EVENT_RECOGNIZER_MAP, GESTURE_EVENT_ALIASES, RECOGNIZERS, RECOGNIZER_COMPATIBLE_MAP, RECOGNIZER_FALLBACK_MAP } from './constants';\nvar DEFAULT_OPTIONS = {\n  events: null,\n  recognizers: null,\n  recognizerOptions: {},\n  Manager: Manager,\n  touchAction: 'none',\n  tabIndex: 0\n};\n\nvar EventManager = function () {\n  function EventManager() {\n    var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, EventManager);\n\n    this.options = Object.assign({}, DEFAULT_OPTIONS, options);\n    this.events = new Map();\n    this._onBasicInput = this._onBasicInput.bind(this);\n    this._onOtherEvent = this._onOtherEvent.bind(this);\n    this.setElement(element);\n    var events = options.events;\n\n    if (events) {\n      this.on(events);\n    }\n  }\n\n  _createClass(EventManager, [{\n    key: \"setElement\",\n    value: function setElement(element) {\n      var _this = this;\n\n      if (this.element) {\n        this.destroy();\n      }\n\n      this.element = element;\n\n      if (!element) {\n        return;\n      }\n\n      var options = this.options;\n      var ManagerClass = options.Manager;\n      this.manager = new ManagerClass(element, {\n        touchAction: options.touchAction,\n        recognizers: options.recognizers || RECOGNIZERS\n      }).on('hammer.input', this._onBasicInput);\n\n      if (!options.recognizers) {\n        Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach(function (name) {\n          var recognizer = _this.manager.get(name);\n\n          if (recognizer) {\n            RECOGNIZER_COMPATIBLE_MAP[name].forEach(function (otherName) {\n              recognizer.recognizeWith(otherName);\n            });\n          }\n        });\n      }\n\n      for (var recognizerName in options.recognizerOptions) {\n        var recognizer = this.manager.get(recognizerName);\n\n        if (recognizer) {\n          var recognizerOption = options.recognizerOptions[recognizerName];\n          delete recognizerOption.enable;\n          recognizer.set(recognizerOption);\n        }\n      }\n\n      this.wheelInput = new WheelInput(element, this._onOtherEvent, {\n        enable: false\n      });\n      this.moveInput = new MoveInput(element, this._onOtherEvent, {\n        enable: false\n      });\n      this.keyInput = new KeyInput(element, this._onOtherEvent, {\n        enable: false,\n        tabIndex: options.tabIndex\n      });\n      this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {\n        enable: false\n      });\n\n      var _iterator = _createForOfIteratorHelper(this.events),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              eventAlias = _step$value[0],\n              eventRegistrar = _step$value[1];\n\n          if (!eventRegistrar.isEmpty()) {\n            this._toggleRecognizer(eventRegistrar.recognizerName, true);\n\n            this.manager.on(eventAlias, eventRegistrar.handleEvent);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.element) {\n        this.wheelInput.destroy();\n        this.moveInput.destroy();\n        this.keyInput.destroy();\n        this.contextmenuInput.destroy();\n        this.manager.destroy();\n        this.wheelInput = null;\n        this.moveInput = null;\n        this.keyInput = null;\n        this.contextmenuInput = null;\n        this.manager = null;\n        this.element = null;\n      }\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, handler, opts) {\n      this._addEventHandler(event, handler, opts, false);\n    }\n  }, {\n    key: \"once\",\n    value: function once(event, handler, opts) {\n      this._addEventHandler(event, handler, opts, true);\n    }\n  }, {\n    key: \"watch\",\n    value: function watch(event, handler, opts) {\n      this._addEventHandler(event, handler, opts, false, true);\n    }\n  }, {\n    key: \"off\",\n    value: function off(event, handler) {\n      this._removeEventHandler(event, handler);\n    }\n  }, {\n    key: \"_toggleRecognizer\",\n    value: function _toggleRecognizer(name, enabled) {\n      var manager = this.manager;\n\n      if (!manager) {\n        return;\n      }\n\n      var recognizer = manager.get(name);\n\n      if (recognizer && recognizer.options.enable !== enabled) {\n        recognizer.set({\n          enable: enabled\n        });\n        var fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];\n\n        if (fallbackRecognizers && !this.options.recognizers) {\n          fallbackRecognizers.forEach(function (otherName) {\n            var otherRecognizer = manager.get(otherName);\n\n            if (enabled) {\n              otherRecognizer.requireFailure(name);\n              recognizer.dropRequireFailure(otherName);\n            } else {\n              otherRecognizer.dropRequireFailure(name);\n            }\n          });\n        }\n      }\n\n      this.wheelInput.enableEventType(name, enabled);\n      this.moveInput.enableEventType(name, enabled);\n      this.keyInput.enableEventType(name, enabled);\n      this.contextmenuInput.enableEventType(name, enabled);\n    }\n  }, {\n    key: \"_addEventHandler\",\n    value: function _addEventHandler(event, handler, opts, once, passive) {\n      if (typeof event !== 'string') {\n        opts = handler;\n\n        for (var eventName in event) {\n          this._addEventHandler(eventName, event[eventName], opts, once, passive);\n        }\n\n        return;\n      }\n\n      var manager = this.manager,\n          events = this.events;\n      var eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n      var eventRegistrar = events.get(eventAlias);\n\n      if (!eventRegistrar) {\n        eventRegistrar = new EventRegistrar(this);\n        events.set(eventAlias, eventRegistrar);\n        eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;\n\n        if (manager) {\n          manager.on(eventAlias, eventRegistrar.handleEvent);\n        }\n      }\n\n      eventRegistrar.add(event, handler, opts, once, passive);\n\n      if (!eventRegistrar.isEmpty()) {\n        this._toggleRecognizer(eventRegistrar.recognizerName, true);\n      }\n    }\n  }, {\n    key: \"_removeEventHandler\",\n    value: function _removeEventHandler(event, handler) {\n      if (typeof event !== 'string') {\n        for (var eventName in event) {\n          this._removeEventHandler(eventName, event[eventName]);\n        }\n\n        return;\n      }\n\n      var events = this.events;\n      var eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n      var eventRegistrar = events.get(eventAlias);\n\n      if (!eventRegistrar) {\n        return;\n      }\n\n      eventRegistrar.remove(event, handler);\n\n      if (eventRegistrar.isEmpty()) {\n        var recognizerName = eventRegistrar.recognizerName;\n        var isRecognizerUsed = false;\n\n        var _iterator2 = _createForOfIteratorHelper(events.values()),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var eh = _step2.value;\n\n            if (eh.recognizerName === recognizerName && !eh.isEmpty()) {\n              isRecognizerUsed = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        if (!isRecognizerUsed) {\n          this._toggleRecognizer(recognizerName, false);\n        }\n      }\n    }\n  }, {\n    key: \"_onBasicInput\",\n    value: function _onBasicInput(event) {\n      var srcEvent = event.srcEvent;\n      var alias = BASIC_EVENT_ALIASES[srcEvent.type];\n\n      if (alias) {\n        this.manager.emit(alias, event);\n      }\n    }\n  }, {\n    key: \"_onOtherEvent\",\n    value: function _onOtherEvent(event) {\n      this.manager.emit(event.type, event);\n    }\n  }]);\n\n  return EventManager;\n}();\n\nexport { EventManager as default };","map":{"version":3,"sources":["../../src/event-manager.js"],"names":["DEFAULT_OPTIONS","events","recognizers","recognizerOptions","Manager","touchAction","tabIndex","EventManager","element","options","Object","ManagerClass","RECOGNIZERS","recognizer","RECOGNIZER_COMPATIBLE_MAP","recognizerOption","enable","eventAlias","eventRegistrar","event","handler","opts","name","enabled","manager","fallbackRecognizers","RECOGNIZER_FALLBACK_MAP","otherRecognizer","once","passive","GESTURE_EVENT_ALIASES","EVENT_RECOGNIZER_MAP","recognizerName","isRecognizerUsed","eh","srcEvent","alias","BASIC_EVENT_ALIASES"],"mappings":"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","sourcesContent":["// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Manager} from './utils/hammer';\n\nimport WheelInput from './inputs/wheel-input';\nimport MoveInput from './inputs/move-input';\nimport KeyInput from './inputs/key-input';\nimport ContextmenuInput from './inputs/contextmenu-input';\n\nimport EventRegistrar from './utils/event-registrar';\n\nimport {\n  BASIC_EVENT_ALIASES,\n  EVENT_RECOGNIZER_MAP,\n  GESTURE_EVENT_ALIASES,\n  RECOGNIZERS,\n  RECOGNIZER_COMPATIBLE_MAP,\n  RECOGNIZER_FALLBACK_MAP\n} from './constants';\n\nconst DEFAULT_OPTIONS = {\n  // event handlers\n  events: null,\n  // custom recognizers\n  recognizers: null,\n  recognizerOptions: {},\n  // Manager class\n  Manager,\n  // allow browser default touch action\n  // https://github.com/uber/react-map-gl/issues/506\n  touchAction: 'none',\n  tabIndex: 0\n};\n\n// Unified API for subscribing to events about both\n// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')\n// and gestural input (e.g. 'click', 'tap', 'panstart').\n// Delegates gesture related event registration and handling to Hammer.js.\nexport default class EventManager {\n  constructor(element = null, options = {}) {\n    this.options = Object.assign({}, DEFAULT_OPTIONS, options);\n    this.events = new Map();\n\n    this._onBasicInput = this._onBasicInput.bind(this);\n    this._onOtherEvent = this._onOtherEvent.bind(this);\n\n    this.setElement(element);\n\n    // Register all passed events.\n    const {events} = options;\n    if (events) {\n      this.on(events);\n    }\n  }\n\n  setElement(element) {\n    if (this.element) {\n      // unregister all events\n      this.destroy();\n    }\n    this.element = element;\n    if (!element) {\n      return;\n    }\n\n    const {options} = this;\n    const ManagerClass = options.Manager;\n\n    this.manager = new ManagerClass(element, {\n      touchAction: options.touchAction,\n      recognizers: options.recognizers || RECOGNIZERS\n    }).on('hammer.input', this._onBasicInput);\n\n    if (!options.recognizers) {\n      // Set default recognize withs\n      // http://hammerjs.github.io/recognize-with/\n      Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach(name => {\n        const recognizer = this.manager.get(name);\n        if (recognizer) {\n          RECOGNIZER_COMPATIBLE_MAP[name].forEach(otherName => {\n            recognizer.recognizeWith(otherName);\n          });\n        }\n      });\n    }\n\n    // Set recognizer options\n    for (const recognizerName in options.recognizerOptions) {\n      const recognizer = this.manager.get(recognizerName);\n      if (recognizer) {\n        const recognizerOption = options.recognizerOptions[recognizerName];\n        // `enable` is managed by the event registrations\n        delete recognizerOption.enable;\n        recognizer.set(recognizerOption);\n      }\n    }\n\n    // Handle events not handled by Hammer.js:\n    // - mouse wheel\n    // - pointer/touch/mouse move\n    this.wheelInput = new WheelInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.moveInput = new MoveInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.keyInput = new KeyInput(element, this._onOtherEvent, {\n      enable: false,\n      tabIndex: options.tabIndex\n    });\n    this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {\n      enable: false\n    });\n\n    // Register all existing events\n    for (const [eventAlias, eventRegistrar] of this.events) {\n      if (!eventRegistrar.isEmpty()) {\n        // Enable recognizer for this event.\n        this._toggleRecognizer(eventRegistrar.recognizerName, true);\n        this.manager.on(eventAlias, eventRegistrar.handleEvent);\n      }\n    }\n  }\n\n  // Tear down internal event management implementations.\n  destroy() {\n    if (this.element) {\n      // wheelInput etc. are created in setElement() and therefore\n      // cannot exist if there is no element\n      this.wheelInput.destroy();\n      this.moveInput.destroy();\n      this.keyInput.destroy();\n      this.contextmenuInput.destroy();\n      this.manager.destroy();\n\n      this.wheelInput = null;\n      this.moveInput = null;\n      this.keyInput = null;\n      this.contextmenuInput = null;\n      this.manager = null;\n      this.element = null;\n    }\n  }\n\n  // Register an event handler function to be called on `event`.\n  on(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, false);\n  }\n\n  // Register an event handler function to be called on `event`, then remove it\n  once(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, true);\n  }\n\n  // Register an event handler function to be called on `event`\n  // This handler does not ask the event to be recognized at all times.\n  // Instead, it only \"intercepts\" the event if some other handler is getting it.\n  watch(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, false, true);\n  }\n\n  /**\n   * Deregister a previously-registered event handler.\n   * @param {string|Object} event   An event name (String) or map of event names to handlers\n   * @param {Function} [handler]    The function to be called on `event`.\n   */\n  off(event, handler) {\n    this._removeEventHandler(event, handler);\n  }\n\n  /*\n   * Enable/disable recognizer for the given event\n   */\n  _toggleRecognizer(name, enabled) {\n    const {manager} = this;\n    if (!manager) {\n      return;\n    }\n    const recognizer = manager.get(name);\n    if (recognizer && recognizer.options.enable !== enabled) {\n      recognizer.set({enable: enabled});\n\n      const fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];\n      if (fallbackRecognizers && !this.options.recognizers) {\n        // Set default require failures\n        // http://hammerjs.github.io/require-failure/\n        fallbackRecognizers.forEach(otherName => {\n          const otherRecognizer = manager.get(otherName);\n          if (enabled) {\n            // Wait for this recognizer to fail\n            otherRecognizer.requireFailure(name);\n            /**\n             * This seems to be a bug in hammerjs:\n             * requireFailure() adds both ways\n             * dropRequireFailure() only drops one way\n             * https://github.com/hammerjs/hammer.js/blob/master/src/recognizerjs/\n               recognizer-constructor.js#L136\n             */\n            recognizer.dropRequireFailure(otherName);\n          } else {\n            // Do not wait for this recognizer to fail\n            otherRecognizer.dropRequireFailure(name);\n          }\n        });\n      }\n    }\n    this.wheelInput.enableEventType(name, enabled);\n    this.moveInput.enableEventType(name, enabled);\n    this.keyInput.enableEventType(name, enabled);\n    this.contextmenuInput.enableEventType(name, enabled);\n  }\n\n  /**\n   * Process the event registration for a single event + handler.\n   */\n  _addEventHandler(event, handler, opts, once, passive) {\n    if (typeof event !== 'string') {\n      opts = handler;\n      // If `event` is a map, call `on()` for each entry.\n      for (const eventName in event) {\n        this._addEventHandler(eventName, event[eventName], opts, once, passive);\n      }\n      return;\n    }\n\n    const {manager, events} = this;\n    // Alias to a recognized gesture as necessary.\n    const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n\n    let eventRegistrar = events.get(eventAlias);\n    if (!eventRegistrar) {\n      eventRegistrar = new EventRegistrar(this);\n      events.set(eventAlias, eventRegistrar);\n      // Enable recognizer for this event.\n      eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;\n      // Listen to the event\n      if (manager) {\n        manager.on(eventAlias, eventRegistrar.handleEvent);\n      }\n    }\n    eventRegistrar.add(event, handler, opts, once, passive);\n    if (!eventRegistrar.isEmpty()) {\n      this._toggleRecognizer(eventRegistrar.recognizerName, true);\n    }\n  }\n\n  /**\n   * Process the event deregistration for a single event + handler.\n   */\n  _removeEventHandler(event, handler) {\n    if (typeof event !== 'string') {\n      // If `event` is a map, call `off()` for each entry.\n      for (const eventName in event) {\n        this._removeEventHandler(eventName, event[eventName]);\n      }\n      return;\n    }\n\n    const {events} = this;\n    // Alias to a recognized gesture as necessary.\n    const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n\n    const eventRegistrar = events.get(eventAlias);\n\n    if (!eventRegistrar) {\n      return;\n    }\n\n    eventRegistrar.remove(event, handler);\n\n    if (eventRegistrar.isEmpty()) {\n      const {recognizerName} = eventRegistrar;\n      // Disable recognizer if no more handlers are attached to its events\n      let isRecognizerUsed = false;\n      for (const eh of events.values()) {\n        if (eh.recognizerName === recognizerName && !eh.isEmpty()) {\n          isRecognizerUsed = true;\n          break;\n        }\n      }\n      if (!isRecognizerUsed) {\n        this._toggleRecognizer(recognizerName, false);\n      }\n    }\n  }\n\n  /**\n   * Handle basic events using the 'hammer.input' Hammer.js API:\n   * Before running Recognizers, Hammer emits a 'hammer.input' event\n   * with the basic event info. This function emits all basic events\n   * aliased to the \"class\" of event received.\n   * See constants.BASIC_EVENT_CLASSES basic event class definitions.\n   */\n  _onBasicInput(event) {\n    const {srcEvent} = event;\n    const alias = BASIC_EVENT_ALIASES[srcEvent.type];\n    if (alias) {\n      // fire all events aliased to srcEvent.type\n      this.manager.emit(alias, event);\n    }\n  }\n\n  /**\n   * Handle events not supported by Hammer.js,\n   * and pipe back out through same (Hammer) channel used by other events.\n   */\n  _onOtherEvent(event) {\n    // console.log('onotherevent', event.type, event)\n    this.manager.emit(event.type, event);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}