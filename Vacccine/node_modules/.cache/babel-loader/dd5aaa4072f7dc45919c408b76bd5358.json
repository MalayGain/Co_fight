{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport { lerp } from './math-utils';\nimport { scaleToZoom, zoomToScale, lngLatToWorld, worldToLngLat } from './web-mercator-utils';\nimport * as vec2 from 'gl-matrix/vec2';\nvar EPSILON = 0.01;\nvar VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'];\nvar DEFAULT_OPTS = {\n  curve: 1.414,\n  speed: 1.2\n};\nexport default function flyToViewport(startProps, endProps, t) {\n  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var viewport = {};\n\n  var _getFlyToTransitionPa = getFlyToTransitionParams(startProps, endProps, opts),\n      startZoom = _getFlyToTransitionPa.startZoom,\n      startCenterXY = _getFlyToTransitionPa.startCenterXY,\n      uDelta = _getFlyToTransitionPa.uDelta,\n      w0 = _getFlyToTransitionPa.w0,\n      u1 = _getFlyToTransitionPa.u1,\n      S = _getFlyToTransitionPa.S,\n      rho = _getFlyToTransitionPa.rho,\n      rho2 = _getFlyToTransitionPa.rho2,\n      r0 = _getFlyToTransitionPa.r0;\n\n  if (u1 < EPSILON) {\n    var _iterator = _createForOfIteratorHelper(VIEWPORT_TRANSITION_PROPS),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var key = _step.value;\n        var startValue = startProps[key];\n        var endValue = endProps[key];\n        viewport[key] = lerp(startValue, endValue, t);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return viewport;\n  }\n\n  var s = t * S;\n  var w = Math.cosh(r0) / Math.cosh(r0 + rho * s);\n  var u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;\n  var scaleIncrement = 1 / w;\n  var newZoom = startZoom + scaleToZoom(scaleIncrement);\n  var newCenterWorld = vec2.scale([], uDelta, u);\n  vec2.add(newCenterWorld, newCenterWorld, startCenterXY);\n  var newCenter = worldToLngLat(newCenterWorld);\n  viewport.longitude = newCenter[0];\n  viewport.latitude = newCenter[1];\n  viewport.zoom = newZoom;\n  return viewport;\n}\nexport function getFlyToDuration(startProps, endProps) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  opts = Object.assign({}, DEFAULT_OPTS, opts);\n  var _opts = opts,\n      screenSpeed = _opts.screenSpeed,\n      speed = _opts.speed,\n      maxDuration = _opts.maxDuration;\n\n  var _getFlyToTransitionPa2 = getFlyToTransitionParams(startProps, endProps, opts),\n      S = _getFlyToTransitionPa2.S,\n      rho = _getFlyToTransitionPa2.rho;\n\n  var length = 1000 * S;\n  var duration;\n\n  if (Number.isFinite(screenSpeed)) {\n    duration = length / (screenSpeed / rho);\n  } else {\n    duration = length / speed;\n  }\n\n  return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;\n}\n\nfunction getFlyToTransitionParams(startProps, endProps, opts) {\n  opts = Object.assign({}, DEFAULT_OPTS, opts);\n  var rho = opts.curve;\n  var startZoom = startProps.zoom;\n  var startCenter = [startProps.longitude, startProps.latitude];\n  var startScale = zoomToScale(startZoom);\n  var endZoom = endProps.zoom;\n  var endCenter = [endProps.longitude, endProps.latitude];\n  var scale = zoomToScale(endZoom - startZoom);\n  var startCenterXY = lngLatToWorld(startCenter);\n  var endCenterXY = lngLatToWorld(endCenter);\n  var uDelta = vec2.sub([], endCenterXY, startCenterXY);\n  var w0 = Math.max(startProps.width, startProps.height);\n  var w1 = w0 / scale;\n  var u1 = vec2.length(uDelta) * startScale;\n\n  var _u1 = Math.max(u1, EPSILON);\n\n  var rho2 = rho * rho;\n  var b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);\n  var b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);\n  var r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);\n  var r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n  var S = (r1 - r0) / rho;\n  return {\n    startZoom: startZoom,\n    startCenterXY: startCenterXY,\n    uDelta: uDelta,\n    w0: w0,\n    u1: u1,\n    S: S,\n    rho: rho,\n    rho2: rho2,\n    r0: r0,\n    r1: r1\n  };\n}","map":{"version":3,"sources":["../../src/fly-to-viewport.js"],"names":["EPSILON","VIEWPORT_TRANSITION_PROPS","DEFAULT_OPTS","curve","speed","opts","viewport","startZoom","startCenterXY","uDelta","w0","u1","S","rho","rho2","r0","getFlyToTransitionParams","key","startValue","startProps","endValue","endProps","lerp","s","t","w","Math","u","scaleIncrement","newZoom","scaleToZoom","newCenterWorld","vec2","newCenter","worldToLngLat","Object","screenSpeed","maxDuration","length","Number","duration","startCenter","startScale","zoomToScale","endZoom","endCenter","scale","lngLatToWorld","endCenterXY","w1","_u1","b0","b1","r1"],"mappings":"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","sourcesContent":["import {lerp} from './math-utils';\nimport {scaleToZoom, zoomToScale, lngLatToWorld, worldToLngLat} from './web-mercator-utils';\nimport * as vec2 from 'gl-matrix/vec2';\n\nconst EPSILON = 0.01;\nconst VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'];\nconst DEFAULT_OPTS = {\n  curve: 1.414,\n  speed: 1.2\n  // screenSpeed and maxDuration are used only if specified\n};\n\n/**\n * mapbox-gl-js flyTo : https://www.mapbox.com/mapbox-gl-js/api/#map#flyto.\n * It implements “Smooth and efficient zooming and panning.” algorithm by\n * \"Jarke J. van Wijk and Wim A.A. Nuij\"\n */\nexport default function flyToViewport(startProps, endProps, t, opts = {}) {\n  // Equations from above paper are referred where needed.\n\n  const viewport = {};\n\n  const {startZoom, startCenterXY, uDelta, w0, u1, S, rho, rho2, r0} = getFlyToTransitionParams(\n    startProps,\n    endProps,\n    opts\n  );\n\n  // If change in center is too small, do linear interpolaiton.\n  if (u1 < EPSILON) {\n    for (const key of VIEWPORT_TRANSITION_PROPS) {\n      const startValue = startProps[key];\n      const endValue = endProps[key];\n      viewport[key] = lerp(startValue, endValue, t);\n    }\n    return viewport;\n  }\n\n  const s = t * S;\n\n  const w = Math.cosh(r0) / Math.cosh(r0 + rho * s);\n  const u = (w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2)) / u1;\n\n  const scaleIncrement = 1 / w; // Using w method for scaling.\n  const newZoom = startZoom + scaleToZoom(scaleIncrement);\n\n  const newCenterWorld = vec2.scale([], uDelta, u);\n  vec2.add(newCenterWorld, newCenterWorld, startCenterXY);\n\n  const newCenter = worldToLngLat(newCenterWorld);\n  viewport.longitude = newCenter[0];\n  viewport.latitude = newCenter[1];\n  viewport.zoom = newZoom;\n  return viewport;\n}\n\n// returns transition duration in milliseconds\nexport function getFlyToDuration(startProps, endProps, opts = {}) {\n  opts = Object.assign({}, DEFAULT_OPTS, opts);\n  const {screenSpeed, speed, maxDuration} = opts;\n  const {S, rho} = getFlyToTransitionParams(startProps, endProps, opts);\n  const length = 1000 * S;\n  let duration;\n  if (Number.isFinite(screenSpeed)) {\n    duration = length / (screenSpeed / rho);\n  } else {\n    duration = length / speed;\n  }\n\n  return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;\n}\n\n// Private Methods\n\n// Calculate all parameters that are static for given startProps and endProps\nfunction getFlyToTransitionParams(startProps, endProps, opts) {\n  opts = Object.assign({}, DEFAULT_OPTS, opts);\n  const rho = opts.curve;\n  const startZoom = startProps.zoom;\n  const startCenter = [startProps.longitude, startProps.latitude];\n  const startScale = zoomToScale(startZoom);\n  const endZoom = endProps.zoom;\n  const endCenter = [endProps.longitude, endProps.latitude];\n  const scale = zoomToScale(endZoom - startZoom);\n\n  const startCenterXY = lngLatToWorld(startCenter);\n  const endCenterXY = lngLatToWorld(endCenter);\n  const uDelta = vec2.sub([], endCenterXY, startCenterXY);\n\n  const w0 = Math.max(startProps.width, startProps.height);\n  const w1 = w0 / scale;\n  const u1 = vec2.length(uDelta) * startScale;\n  // u0 is treated as '0' in Eq (9).\n\n  // If u1 is too small, will generate invalid number\n  const _u1 = Math.max(u1, EPSILON);\n\n  // Implement Equation (9) from above algorithm.\n  const rho2 = rho * rho;\n  const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);\n  const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);\n  const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);\n  const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n  const S = (r1 - r0) / rho;\n\n  return {startZoom, startCenterXY, uDelta, w0, u1, S, rho, rho2, r0, r1};\n}\n"]},"metadata":{},"sourceType":"module"}