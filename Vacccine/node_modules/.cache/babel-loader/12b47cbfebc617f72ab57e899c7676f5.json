{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport * as React from 'react';\nimport { PureComponent, createRef } from 'react';\nimport PropTypes from 'prop-types';\nimport MapContext from './map-context';\nvar propTypes = {\n  captureScroll: PropTypes.bool,\n  captureDrag: PropTypes.bool,\n  captureClick: PropTypes.bool,\n  captureDoubleClick: PropTypes.bool,\n  capturePointerMove: PropTypes.bool\n};\nvar defaultProps = {\n  captureScroll: false,\n  captureDrag: true,\n  captureClick: true,\n  captureDoubleClick: true,\n  capturePointerMove: false\n};\n\nvar BaseControl = function (_PureComponent) {\n  _inherits(BaseControl, _PureComponent);\n\n  var _super = _createSuper(BaseControl);\n\n  function BaseControl() {\n    var _this;\n\n    _classCallCheck(this, BaseControl);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"_context\", {});\n\n    _defineProperty(_assertThisInitialized(_this), \"_events\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"_containerRef\", createRef());\n\n    _defineProperty(_assertThisInitialized(_this), \"_onScroll\", function (evt) {\n      if (_this.props.captureScroll) {\n        evt.stopPropagation();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_onDragStart\", function (evt) {\n      if (_this.props.captureDrag) {\n        evt.stopPropagation();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_onDblClick\", function (evt) {\n      if (_this.props.captureDoubleClick) {\n        evt.stopPropagation();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_onClick\", function (evt) {\n      if (_this.props.captureClick) {\n        evt.stopPropagation();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_onPointerMove\", function (evt) {\n      if (_this.props.capturePointerMove) {\n        evt.stopPropagation();\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(BaseControl, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var ref = this._containerRef.current;\n\n      if (!ref) {\n        return;\n      }\n\n      var eventManager = this._context.eventManager;\n\n      if (eventManager) {\n        this._events = {\n          wheel: this._onScroll,\n          panstart: this._onDragStart,\n          anyclick: this._onClick,\n          click: this._onClick,\n          dblclick: this._onDblClick,\n          pointermove: this._onPointerMove\n        };\n        eventManager.watch(this._events, ref);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var eventManager = this._context.eventManager;\n\n      if (eventManager && this._events) {\n        eventManager.off(this._events);\n      }\n    }\n  }, {\n    key: \"_render\",\n    value: function _render() {\n      throw new Error('_render() not implemented');\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      return React.createElement(MapContext.Consumer, null, function (context) {\n        _this2._context = context;\n        return _this2._render();\n      });\n    }\n  }]);\n\n  return BaseControl;\n}(PureComponent);\n\n_defineProperty(BaseControl, \"propTypes\", propTypes);\n\n_defineProperty(BaseControl, \"defaultProps\", defaultProps);\n\nexport { BaseControl as default };","map":{"version":3,"sources":["../../../src/components/base-control.js"],"names":["propTypes","captureScroll","PropTypes","captureDrag","captureClick","captureDoubleClick","capturePointerMove","bool","defaultProps","BaseControl","PureComponent","ref","eventManager","wheel","panstart","anyclick","click","dblclick","pointermove","_onPointerMove","createRef","evt"],"mappings":"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","sourcesContent":["// @flow\n// Copyright (c) 2015 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport * as React from 'react';\nimport {PureComponent, createRef} from 'react';\nimport PropTypes from 'prop-types';\nimport MapContext from './map-context';\n\nimport type {MjolnirEvent} from 'mjolnir.js';\n\nconst propTypes = {\n  /** Event handling */\n  captureScroll: PropTypes.bool,\n  // Stop map pan & rotate\n  captureDrag: PropTypes.bool,\n  // Stop map click\n  captureClick: PropTypes.bool,\n  // Stop map double click\n  captureDoubleClick: PropTypes.bool,\n  // Stop map pointer move\n  capturePointerMove: PropTypes.bool\n};\n\nconst defaultProps = {\n  captureScroll: false,\n  captureDrag: true,\n  captureClick: true,\n  captureDoubleClick: true,\n  capturePointerMove: false\n};\n\nexport type BaseControlProps = {\n  captureScroll: boolean,\n  captureDrag: boolean,\n  captureClick: boolean,\n  captureDoubleClick: boolean,\n  capturePointerMove: boolean,\n  children?: any\n};\n\n/*\n * PureComponent doesn't update when context changes.\n * The only way is to implement our own shouldComponentUpdate here. Considering\n * the parent component (StaticMap or InteractiveMap) is pure, and map re-render\n * is almost always triggered by a viewport change, we almost definitely need to\n * recalculate the marker's position when the parent re-renders.\n */\nexport default class BaseControl<\n  Props: BaseControlProps,\n  State: any,\n  ContainerType: Element\n> extends PureComponent<Props, State> {\n  static propTypes = propTypes;\n  static defaultProps = defaultProps;\n\n  componentDidMount() {\n    const ref = this._containerRef.current;\n    if (!ref) {\n      return;\n    }\n\n    const {eventManager} = this._context;\n\n    // Return early if no eventManager is found\n    if (eventManager) {\n      this._events = {\n        wheel: this._onScroll,\n        panstart: this._onDragStart,\n        anyclick: this._onClick,\n        click: this._onClick,\n        dblclick: this._onDblClick,\n        pointermove: this._onPointerMove\n      };\n      eventManager.watch(this._events, ref);\n    }\n  }\n\n  componentWillUnmount() {\n    const {eventManager} = this._context;\n    if (eventManager && this._events) {\n      eventManager.off(this._events);\n    }\n  }\n\n  _context: any = {};\n  _events: any = null;\n  _containerRef: {current: null | ContainerType} = createRef();\n\n  _onScroll = (evt: MjolnirEvent) => {\n    if (this.props.captureScroll) {\n      evt.stopPropagation();\n    }\n  };\n\n  _onDragStart = (evt: MjolnirEvent) => {\n    if (this.props.captureDrag) {\n      evt.stopPropagation();\n    }\n  };\n\n  _onDblClick = (evt: MjolnirEvent) => {\n    if (this.props.captureDoubleClick) {\n      evt.stopPropagation();\n    }\n  };\n\n  _onClick = (evt: MjolnirEvent) => {\n    if (this.props.captureClick) {\n      evt.stopPropagation();\n    }\n  };\n\n  _onPointerMove = (evt: MjolnirEvent) => {\n    if (this.props.capturePointerMove) {\n      evt.stopPropagation();\n    }\n  };\n\n  _render() {\n    throw new Error('_render() not implemented');\n  }\n\n  render() {\n    return (\n      <MapContext.Consumer>\n        {context => {\n          this._context = context;\n          return this._render();\n        }}\n      </MapContext.Consumer>\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}