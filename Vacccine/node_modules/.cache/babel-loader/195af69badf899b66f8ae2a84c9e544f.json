{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport WebMercatorViewport from './web-mercator-viewport';\nimport assert from './assert';\nexport default function fitBounds(_ref) {\n  var width = _ref.width,\n      height = _ref.height,\n      bounds = _ref.bounds,\n      _ref$minExtent = _ref.minExtent,\n      minExtent = _ref$minExtent === void 0 ? 0 : _ref$minExtent,\n      _ref$maxZoom = _ref.maxZoom,\n      maxZoom = _ref$maxZoom === void 0 ? 24 : _ref$maxZoom,\n      _ref$padding = _ref.padding,\n      padding = _ref$padding === void 0 ? 0 : _ref$padding,\n      _ref$offset = _ref.offset,\n      offset = _ref$offset === void 0 ? [0, 0] : _ref$offset;\n\n  var _bounds = _slicedToArray(bounds, 2),\n      _bounds$ = _slicedToArray(_bounds[0], 2),\n      west = _bounds$[0],\n      south = _bounds$[1],\n      _bounds$2 = _slicedToArray(_bounds[1], 2),\n      east = _bounds$2[0],\n      north = _bounds$2[1];\n\n  if (Number.isFinite(padding)) {\n    var p = padding;\n    padding = {\n      top: p,\n      bottom: p,\n      left: p,\n      right: p\n    };\n  } else {\n    assert(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));\n  }\n\n  var viewport = new WebMercatorViewport({\n    width: width,\n    height: height,\n    longitude: 0,\n    latitude: 0,\n    zoom: 0\n  });\n  var nw = viewport.project([west, north]);\n  var se = viewport.project([east, south]);\n  var size = [Math.max(Math.abs(se[0] - nw[0]), minExtent), Math.max(Math.abs(se[1] - nw[1]), minExtent)];\n  var targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];\n  assert(targetSize[0] > 0 && targetSize[1] > 0);\n  var scaleX = targetSize[0] / size[0];\n  var scaleY = targetSize[1] / size[1];\n  var offsetX = (padding.right - padding.left) / 2 / scaleX;\n  var offsetY = (padding.bottom - padding.top) / 2 / scaleY;\n  var center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];\n  var centerLngLat = viewport.unproject(center);\n  var zoom = Math.min(maxZoom, viewport.zoom + Math.log2(Math.abs(Math.min(scaleX, scaleY))));\n  assert(Number.isFinite(zoom));\n  return {\n    longitude: centerLngLat[0],\n    latitude: centerLngLat[1],\n    zoom: zoom\n  };\n}","map":{"version":3,"sources":["../../src/fit-bounds.js"],"names":["width","height","bounds","minExtent","maxZoom","padding","offset","west","south","east","north","Number","p","top","bottom","left","right","assert","viewport","longitude","latitude","zoom","nw","se","size","Math","targetSize","scaleX","scaleY","offsetX","offsetY","center","centerLngLat"],"mappings":"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","sourcesContent":["// @ts-nocheck TODO padding\nimport WebMercatorViewport from './web-mercator-viewport';\nimport assert from './assert';\n\n// Returns map settings {latitude, longitude, zoom}\n// that will contain the provided corners within the provided width.\n// Only supports non-perspective mode.\n\nexport default function fitBounds({\n  width,\n  height,\n  bounds,\n  minExtent = 0, // 0.01 would be about 1000 meters (degree is ~110KM)\n  maxZoom = 24, // ~x4,000,000 => About 10 meter extents\n  // options\n  padding = 0,\n  offset = [0, 0]\n}) {\n  const [[west, south], [east, north]] = bounds;\n\n  if (Number.isFinite(padding)) {\n    const p = padding;\n    padding = {\n      top: p,\n      bottom: p,\n      left: p,\n      right: p\n    };\n  } else {\n    // Make sure all the required properties are set\n    assert(\n      Number.isFinite(padding.top) &&\n        Number.isFinite(padding.bottom) &&\n        Number.isFinite(padding.left) &&\n        Number.isFinite(padding.right)\n    );\n  }\n\n  const viewport = new WebMercatorViewport({\n    width,\n    height,\n    longitude: 0,\n    latitude: 0,\n    zoom: 0\n  });\n\n  const nw = viewport.project([west, north]);\n  const se = viewport.project([east, south]);\n\n  // width/height on the Web Mercator plane\n  const size = [\n    Math.max(Math.abs(se[0] - nw[0]), minExtent),\n    Math.max(Math.abs(se[1] - nw[1]), minExtent)\n  ];\n\n  const targetSize = [\n    width - padding.left - padding.right - Math.abs(offset[0]) * 2,\n    height - padding.top - padding.bottom - Math.abs(offset[1]) * 2\n  ];\n\n  assert(targetSize[0] > 0 && targetSize[1] > 0);\n\n  // scale = screen pixels per unit on the Web Mercator plane\n  const scaleX = targetSize[0] / size[0];\n  const scaleY = targetSize[1] / size[1];\n\n  // Find how much we need to shift the center\n  const offsetX = (padding.right - padding.left) / 2 / scaleX;\n  const offsetY = (padding.bottom - padding.top) / 2 / scaleY;\n\n  const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];\n\n  const centerLngLat = viewport.unproject(center);\n  const zoom = Math.min(maxZoom, viewport.zoom + Math.log2(Math.abs(Math.min(scaleX, scaleY))));\n\n  assert(Number.isFinite(zoom));\n\n  return {\n    longitude: centerLngLat[0],\n    latitude: centerLngLat[1],\n    zoom\n  };\n}\n"]},"metadata":{},"sourceType":"module"}