{"ast":null,"code":"import { worldToLngLat } from './web-mercator-utils';\nimport * as vec2 from 'gl-matrix/vec2';\nimport { transformVector } from './math-utils';\nvar DEGREES_TO_RADIANS = Math.PI / 180;\nexport default function getBounds(viewport) {\n  var z = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var width = viewport.width,\n      height = viewport.height,\n      unproject = viewport.unproject;\n  var unprojectOps = {\n    targetZ: z\n  };\n  var bottomLeft = unproject([0, height], unprojectOps);\n  var bottomRight = unproject([width, height], unprojectOps);\n  var topLeft;\n  var topRight;\n  var halfFov = Math.atan(0.5 / viewport.altitude);\n  var angleToGround = (90 - viewport.pitch) * DEGREES_TO_RADIANS;\n\n  if (halfFov > angleToGround - 0.01) {\n    topLeft = unprojectOnFarPlane(viewport, 0, z);\n    topRight = unprojectOnFarPlane(viewport, width, z);\n  } else {\n    topLeft = unproject([0, 0], unprojectOps);\n    topRight = unproject([width, 0], unprojectOps);\n  }\n\n  return [bottomLeft, bottomRight, topRight, topLeft];\n}\n\nfunction unprojectOnFarPlane(viewport, x, targetZ) {\n  var pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;\n  var coord0 = transformVector(pixelUnprojectionMatrix, [x, 0, 1, 1]);\n  var coord1 = transformVector(pixelUnprojectionMatrix, [x, viewport.height, 1, 1]);\n  var z = targetZ * viewport.distanceScales.unitsPerMeter[2];\n  var t = (z - coord0[2]) / (coord1[2] - coord0[2]);\n  var coord = vec2.lerp([], coord0, coord1, t);\n  var result = worldToLngLat(coord);\n  result[2] = targetZ;\n  return result;\n}","map":{"version":3,"sources":["../../src/get-bounds.js"],"names":["DEGREES_TO_RADIANS","Math","z","width","height","unproject","viewport","unprojectOps","targetZ","bottomLeft","bottomRight","halfFov","angleToGround","topLeft","unprojectOnFarPlane","topRight","pixelUnprojectionMatrix","coord0","transformVector","coord1","t","coord","vec2","result","worldToLngLat"],"mappings":"AAAA,SAAA,aAAA,QAAA,sBAAA;AACA,OAAO,KAAP,IAAA,MAAA,gBAAA;AACA,SAAA,eAAA,QAAA,cAAA;AAEA,IAAMA,kBAAkB,GAAGC,IAAI,CAAJA,EAAAA,GAA3B,GAAA;AAOA,eAAe,SAAA,SAAA,CAAA,QAAA,EAAoC;AAAA,MAAPC,CAAO,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAH,CAAG;AAAA,MAC1CC,KAD0C,GACdG,QADc,CAAA,KAAA;AAAA,MACnCF,MADmC,GACdE,QADc,CAAA,MAAA;AAAA,MAC3BD,SAD2B,GACdC,QADc,CAAA,SAAA;AAEjD,MAAMC,YAAY,GAAG;AAACC,IAAAA,OAAO,EAAEN;AAAV,GAArB;AACA,MAAMO,UAAU,GAAGJ,SAAS,CAAC,CAAA,CAAA,EAAD,MAAC,CAAD,EAA5B,YAA4B,CAA5B;AACA,MAAMK,WAAW,GAAGL,SAAS,CAAC,CAAA,KAAA,EAAD,MAAC,CAAD,EAA7B,YAA6B,CAA7B;AACA,MAAA,OAAA;AACA,MAAA,QAAA;AAEA,MAAMM,OAAO,GAAGV,IAAI,CAAJA,IAAAA,CAAU,MAAMK,QAAQ,CAAxC,QAAgBL,CAAhB;AACA,MAAMW,aAAa,GAAG,CAAC,KAAKN,QAAQ,CAAd,KAAA,IAAtB,kBAAA;;AAEA,MAAIK,OAAO,GAAGC,aAAa,GAA3B,IAAA,EAAoC;AAElCC,IAAAA,OAAO,GAAGC,mBAAmB,CAAA,QAAA,EAAA,CAAA,EAA7BD,CAA6B,CAA7BA;AACAE,IAAAA,QAAQ,GAAGD,mBAAmB,CAAA,QAAA,EAAA,KAAA,EAA9BC,CAA8B,CAA9BA;AAHF,GAAA,MAIO;AAELF,IAAAA,OAAO,GAAGR,SAAS,CAAC,CAAA,CAAA,EAAD,CAAC,CAAD,EAAnBQ,YAAmB,CAAnBA;AACAE,IAAAA,QAAQ,GAAGV,SAAS,CAAC,CAAA,KAAA,EAAD,CAAC,CAAD,EAApBU,YAAoB,CAApBA;AACD;;AAED,SAAO,CAAA,UAAA,EAAA,WAAA,EAAA,QAAA,EAAP,OAAO,CAAP;AACD;;AAQD,SAAA,mBAAA,CAAA,QAAA,EAAA,CAAA,EAAA,OAAA,EAAmD;AAAA,MAC1CC,uBAD0C,GACfV,QADe,CAAA,uBAAA;AAEjD,MAAMW,MAAM,GAAGC,eAAe,CAAA,uBAAA,EAA0B,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAxD,CAAwD,CAA1B,CAA9B;AACA,MAAMC,MAAM,GAAGD,eAAe,CAAA,uBAAA,EAA0B,CAAA,CAAA,EAAIZ,QAAQ,CAAZ,MAAA,EAAA,CAAA,EAAxD,CAAwD,CAA1B,CAA9B;AAEA,MAAMJ,CAAC,GAAGM,OAAO,GAAGF,QAAQ,CAARA,cAAAA,CAAAA,aAAAA,CAApB,CAAoBA,CAApB;AACA,MAAMc,CAAC,GAAG,CAAClB,CAAC,GAAGe,MAAM,CAAX,CAAW,CAAX,KAAmBE,MAAM,CAANA,CAAM,CAANA,GAAYF,MAAM,CAA/C,CAA+C,CAArC,CAAV;AACA,MAAMI,KAAK,GAAGC,IAAI,CAAJA,IAAAA,CAAAA,EAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAd,CAAcA,CAAd;AAEA,MAAMC,MAAM,GAAGC,aAAa,CAA5B,KAA4B,CAA5B;AACAD,EAAAA,MAAM,CAANA,CAAM,CAANA,GAAAA,OAAAA;AACA,SAAA,MAAA;AACD","sourcesContent":["import {worldToLngLat} from './web-mercator-utils';\nimport * as vec2 from 'gl-matrix/vec2';\nimport {transformVector} from './math-utils';\n\nconst DEGREES_TO_RADIANS = Math.PI / 180;\n\n/*\n * Returns the quad at the intersection of the frustum and the given z plane\n * @param {WebMercatorViewport} viewport\n * @param {Number} z - elevation in meters\n */\nexport default function getBounds(viewport, z = 0) {\n  const {width, height, unproject} = viewport;\n  const unprojectOps = {targetZ: z};\n  const bottomLeft = unproject([0, height], unprojectOps);\n  const bottomRight = unproject([width, height], unprojectOps);\n  let topLeft;\n  let topRight;\n\n  const halfFov = Math.atan(0.5 / viewport.altitude);\n  const angleToGround = (90 - viewport.pitch) * DEGREES_TO_RADIANS;\n  // The top plane is parallel to the ground if halfFov == angleToGround\n  if (halfFov > angleToGround - 0.01) {\n    // intersect with the far plane\n    topLeft = unprojectOnFarPlane(viewport, 0, z);\n    topRight = unprojectOnFarPlane(viewport, width, z);\n  } else {\n    // intersect with the top plane\n    topLeft = unproject([0, 0], unprojectOps);\n    topRight = unproject([width, 0], unprojectOps);\n  }\n\n  return [bottomLeft, bottomRight, topRight, topLeft];\n}\n\n/*\n * Find a point on the far clipping plane of the viewport\n * @param {WebMercatorViewport} viewport\n * @param {Number} x - projected x in screen space\n * @param {Number} targetZ - the elevation of the point in meters\n */\nfunction unprojectOnFarPlane(viewport, x, targetZ) {\n  const {pixelUnprojectionMatrix} = viewport;\n  const coord0 = transformVector(pixelUnprojectionMatrix, [x, 0, 1, 1]);\n  const coord1 = transformVector(pixelUnprojectionMatrix, [x, viewport.height, 1, 1]);\n\n  const z = targetZ * viewport.distanceScales.unitsPerMeter[2];\n  const t = (z - coord0[2]) / (coord1[2] - coord0[2]);\n  const coord = vec2.lerp([], coord0, coord1, t);\n\n  const result = worldToLngLat(coord);\n  result[2] = targetZ;\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}